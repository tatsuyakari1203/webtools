'use client'

import React, { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Loader2, Edit, Wand2, Clipboard } from 'lucide-react'
import { toast } from 'sonner'
import { ImageInput } from './ImageInput'
import { useNanoBanana } from '../context/NanoBananaContext'


interface EditTabProps {
  loading: boolean
  setLoading: (loading: boolean) => void
  setGeneratedImage: (image: string | null) => void
}

export const EditTab: React.FC<EditTabProps> = ({
  loading,
  setLoading,
  setGeneratedImage
}) => {
  const { state, updateEditState, startNewSession, setLastGeneratedImage } = useNanoBanana()
  const {
    editImage,
    editImagePreview,
    editPrompt,
    editInstruction,
    editStyle
  } = state
  const [descriptionLoading, setDescriptionLoading] = useState(false)
  const [pasteLoading, setPasteLoading] = useState(false)

  const handleAutoGenerateDescription = async () => {
    if (!editImage) {
      toast.error('Please upload an image first')
      return
    }

    setDescriptionLoading(true)
    try {
      const formData = new FormData()
      formData.append('image', editImage)

      const response = await fetch('/api/nano-banana/describe-image', {
        method: 'POST',
        body: formData
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const result = await response.json()
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to generate description')
      }
      
      // Update the prompt with generated description
      updateEditState({ editPrompt: result.description })
      
      toast.success('Description generated successfully!')
    } catch (error) {
      console.error('Error generating description:', error)
      toast.error('Unable to generate description. Please try again.')
    } finally {
      setDescriptionLoading(false)
    }
  }

  const handlePasteFromClipboard = async () => {
    setPasteLoading(true)
    try {
      // Check if clipboard API is supported
      if (!navigator.clipboard || !navigator.clipboard.read) {
        toast.error('Clipboard API not supported in this browser')
        return
      }

      // Read clipboard contents
      const clipboardItems = await navigator.clipboard.read()
      
      for (const clipboardItem of clipboardItems) {
        // Look for image types
        for (const type of clipboardItem.types) {
          if (type.startsWith('image/')) {
            const blob = await clipboardItem.getType(type)
            
            // Convert blob to File
            const file = new File([blob], 'pasted-image.png', { type: blob.type })
            
            // Create preview URL
            const previewUrl = URL.createObjectURL(blob)
            
            // Update state
            updateEditState({ 
              editImage: file,
              editImagePreview: previewUrl
            })
            
            toast.success('Image pasted from clipboard!')
            return
          }
        }
      }
      
      toast.error('No image found in clipboard')
    } catch (error) {
      console.error('Error pasting from clipboard:', error)
      if (error instanceof Error && error.name === 'NotAllowedError') {
        toast.error('Clipboard access denied. Please allow clipboard permissions.')
      } else {
        toast.error('Unable to paste from clipboard. Please try again.')
      }
    } finally {
      setPasteLoading(false)
    }
  }

  const handleEdit = async () => {
    if (!editImage || !editInstruction.trim()) {
      toast.error('Please upload image and enter edit instructions')
      return
    }

    setLoading(true)
    try {
      const formData = new FormData()
      formData.append('image', editImage)
      formData.append('prompt', editPrompt)
      formData.append('edit_instruction', editInstruction)
      formData.append('style', editStyle)
      formData.append('quality', 'ultra')

      const response = await fetch('/api/nano-banana/edit', {
        method: 'POST',
        body: formData
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      // Handle JSON response with base64 image data
      const result = await response.json()
      
      if (!result.success) {
        throw new Error(result.error || 'Edit failed')
      }
      
      // Convert base64 to blob URL
      const imageUrl = `data:image/png;base64,${result.image_data}`
      
      // Start new session for each edit
      startNewSession()
      setLastGeneratedImage(imageUrl)
      setGeneratedImage(imageUrl)
      
      toast.success('Image edited successfully!')
    } catch (error) {
      console.error('Error editing image:', error)
      toast.error('Unable to connect to server')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="space-y-4">
      <div>
        <div className="flex items-center justify-between">
          <Label htmlFor="edit-image">Upload Image</Label>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={handlePasteFromClipboard}
            disabled={pasteLoading || loading}
            className="text-xs"
          >
            {pasteLoading ? (
              <>
                <Loader2 className="mr-1 h-3 w-3 animate-spin" />
                Pasting...
              </>
            ) : (
              <>
                <Clipboard className="mr-1 h-3 w-3" />
                Paste from Clipboard
              </>
            )}
          </Button>
        </div>
        <div className="mt-1">
          <ImageInput
             label="Upload Image to Edit"
             value={editImage}
             onChange={(file) => updateEditState({ editImage: file })}
             preview={editImagePreview}
             onPreviewChange={(preview) => updateEditState({ editImagePreview: preview })}
           />
        </div>
      </div>

      <div>
        <div className="flex items-center justify-between">
          <Label htmlFor="edit-prompt">Image Description (Optional)</Label>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={handleAutoGenerateDescription}
            disabled={!editImage || descriptionLoading || loading}
            className="text-xs"
          >
            {descriptionLoading ? (
              <>
                <Loader2 className="mr-1 h-3 w-3 animate-spin" />
                Generating...
              </>
            ) : (
              <>
                <Wand2 className="mr-1 h-3 w-3" />
                Auto Generate
              </>
            )}
          </Button>
        </div>
        <Textarea
          id="edit-prompt"
          placeholder="Describe the current image..."
          value={editPrompt}
          onChange={(e) => updateEditState({ editPrompt: e.target.value })}
          rows={4}
          className="mt-1"
        />
      </div>

      <div>
        <Label htmlFor="edit-instruction">Edit Instructions</Label>
        <Textarea
          id="edit-instruction"
          placeholder="Describe what changes you want to make..."
          value={editInstruction}
          onChange={(e) => updateEditState({ editInstruction: e.target.value })}
          rows={3}
          className="mt-1"
        />
      </div>

      <div>
        <Label htmlFor="edit-style">Style</Label>
        <Select value={editStyle} onValueChange={(value) => updateEditState({ editStyle: value })}>
          <SelectTrigger className="mt-1">
            <SelectValue placeholder="Select style" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="photorealistic">Photorealistic</SelectItem>
            <SelectItem value="artistic">Artistic</SelectItem>
            <SelectItem value="cartoon">Cartoon</SelectItem>
            <SelectItem value="anime">Anime</SelectItem>
            <SelectItem value="abstract">Abstract</SelectItem>
          </SelectContent>
        </Select>
      </div>

      <Button 
        onClick={handleEdit} 
        disabled={loading || !editImage || !editInstruction.trim()}
        className="w-full"
      >
        {loading ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Editing...
          </>
        ) : (
          <>
            <Edit className="mr-2 h-4 w-4" />
            Edit Image
          </>
        )}
      </Button>
    </div>
  )
}
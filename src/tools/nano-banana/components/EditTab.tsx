'use client'

import React, { useState } from 'react'
import { Button } from '@/components/ui/button'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import { Checkbox } from '@/components/ui/checkbox'

import { Loader2, Edit, Wand2, Clipboard, Sparkles } from 'lucide-react'
import { toast } from 'sonner'
import { ImageInput } from './ImageInput'
import { useNanoBanana } from '../context/NanoBananaContext'


interface EditTabProps {
  loading: boolean
  setLoading: (loading: boolean) => void
  setGeneratedImage: (image: string | null) => void
}

export const EditTab: React.FC<EditTabProps> = ({
  loading,
  setLoading,
  setGeneratedImage
}) => {
  const { state, updateEditState, startNewSession, setLastGeneratedImage } = useNanoBanana()
  const {
    editImage,
    editImagePreview,
    editPrompt,
    editInstruction
  } = state
  const [descriptionLoading, setDescriptionLoading] = useState(false)
  const [pasteLoading, setPasteLoading] = useState(false)
  const [improvingPrompt, setImprovingPrompt] = useState(false)
  const [originalImageSize, setOriginalImageSize] = useState<{width: number, height: number} | null>(null)
  const [resizeToOriginal, setResizeToOriginal] = useState(true)

  // Function to get image dimensions
  const getImageDimensions = (file: File): Promise<{width: number, height: number}> => {
    return new Promise((resolve) => {
      const img = new Image()
      img.onload = () => {
        resolve({ width: img.naturalWidth, height: img.naturalHeight })
      }
      img.src = URL.createObjectURL(file)
    })
  }

  // Function to resize image to specific dimensions
  const resizeImageToSize = (imageUrl: string, targetWidth: number, targetHeight: number): Promise<string> => {
    return new Promise((resolve) => {
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')!
      const img = new Image()
      
      img.onload = () => {
        canvas.width = targetWidth
        canvas.height = targetHeight
        
        // Draw image resized to exact target dimensions
        ctx.drawImage(img, 0, 0, targetWidth, targetHeight)
        
        // Convert to data URL
        const resizedImageUrl = canvas.toDataURL('image/png')
        resolve(resizedImageUrl)
      }
      
      img.src = imageUrl
    })
  }

  const handleAutoGenerateDescription = async () => {
    if (!editImage) {
      toast.error('Please upload an image first')
      return
    }

    setDescriptionLoading(true)
    try {
      const formData = new FormData()
      formData.append('image', editImage)

      const response = await fetch('/api/nano-banana/describe-image', {
        method: 'POST',
        body: formData
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      const result = await response.json()
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to generate description')
      }
      
      // Update the prompt with generated description
      updateEditState({ editPrompt: result.description })
      
      toast.success('Description generated successfully!')
    } catch (error) {
      console.error('Error generating description:', error)
      toast.error('Unable to generate description. Please try again.')
    } finally {
      setDescriptionLoading(false)
    }
  }

  const handlePasteFromClipboard = async () => {
    setPasteLoading(true)
    try {
      // Check if clipboard API is supported
      if (!navigator.clipboard || !navigator.clipboard.read) {
        toast.error('Clipboard API not supported in this browser')
        return
      }

      // Read clipboard contents
      const clipboardItems = await navigator.clipboard.read()
      
      for (const clipboardItem of clipboardItems) {
        // Look for image types
        for (const type of clipboardItem.types) {
          if (type.startsWith('image/')) {
            const blob = await clipboardItem.getType(type)
            
            // Convert blob to File
            const file = new File([blob], 'pasted-image.png', { type: blob.type })
            
            // Create preview URL
            const previewUrl = URL.createObjectURL(blob)
            
            // Update state
            updateEditState({ 
              editImage: file,
              editImagePreview: previewUrl
            })
            
            toast.success('Image pasted from clipboard!')
            return
          }
        }
      }
      
      toast.error('No image found in clipboard')
    } catch (error) {
      console.error('Error pasting from clipboard:', error)
      if (error instanceof Error && error.name === 'NotAllowedError') {
        toast.error('Clipboard access denied. Please allow clipboard permissions.')
      } else {
        toast.error('Unable to paste from clipboard. Please try again.')
      }
    } finally {
      setPasteLoading(false)
    }
  }

  const handleImprovePrompt = async (category: string) => {
    if (!editInstruction.trim()) {
      toast.error('Please enter edit instructions first')
      return
    }

    setImprovingPrompt(true)
    try {
      const response = await fetch('/api/nano-banana/improve-prompt', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          prompt: editInstruction,
          category
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }))
        throw new Error(errorData.error || `HTTP error! status: ${response.status}`)
      }

      const data = await response.json()
      
      if (data.success && data.improved_prompt) {
        updateEditState({ editInstruction: data.improved_prompt })
        toast.success('Edit instructions improved with detailed steps!')
      } else {
        throw new Error(data.error || 'Failed to improve prompt')
      }
    } catch (error) {
      console.error('Error improving prompt:', error)
      toast.error(error instanceof Error ? error.message : 'Unable to improve prompt')
    } finally {
      setImprovingPrompt(false)
    }
  }

  const handleEdit = async () => {
    if (!editImage || !editInstruction.trim()) {
      toast.error('Please upload image and enter edit instructions')
      return
    }

    setLoading(true)
    try {
      const formData = new FormData()
      formData.append('image', editImage)
      formData.append('prompt', editPrompt)
      formData.append('edit_instruction', editInstruction)
      formData.append('quality', 'ultra')

      const response = await fetch('/api/nano-banana/edit', {
        method: 'POST',
        body: formData
      })

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }

      // Handle JSON response with base64 image data
      const result = await response.json()
      
      if (!result.success) {
        // Display user-friendly error message from backend
        toast.error(result.error || 'Edit failed')
        return
      }
      
      // Convert base64 to blob URL
      let imageUrl = `data:image/png;base64,${result.image_data}`
      
      // Resize to original dimensions if option is enabled and we have original size
      if (resizeToOriginal && originalImageSize) {
        imageUrl = await resizeImageToSize(imageUrl, originalImageSize.width, originalImageSize.height)
      }
      
      // Start new session for each edit
      startNewSession()
      setLastGeneratedImage(imageUrl)
      setGeneratedImage(imageUrl)
      
      toast.success('Image edited successfully!')
    } catch (error) {
      console.error('Error editing image:', error)
      // Check if it's a network error or server error
      if (error instanceof Error && error.message.includes('HTTP error!')) {
        toast.error('Server error occurred. Please try again with different content or image.')
      } else {
        toast.error('Unable to connect to server. Please check your connection.')
      }
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="space-y-4">
      <div>
        <div className="flex items-center justify-between">
          <Label htmlFor="edit-image">Upload Image</Label>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={handlePasteFromClipboard}
            disabled={pasteLoading || loading}
            className="text-xs"
          >
            {pasteLoading ? (
              <>
                <Loader2 className="mr-1 h-3 w-3 animate-spin" />
                Pasting...
              </>
            ) : (
              <>
                <Clipboard className="mr-1 h-3 w-3" />
                Paste from Clipboard
              </>
            )}
          </Button>
        </div>
        <div className="mt-1">
          <ImageInput
             label="Upload Image to Edit"
             value={editImage}
             onChange={async (file) => {
               updateEditState({ editImage: file })
               // Get original image dimensions when file is uploaded
               if (file) {
                 try {
                   const dimensions = await getImageDimensions(file)
                   setOriginalImageSize(dimensions)
                 } catch (error) {
                   console.error('Error getting image dimensions:', error)
                 }
               } else {
                 setOriginalImageSize(null)
               }
             }}
             preview={editImagePreview}
             onPreviewChange={(preview) => updateEditState({ editImagePreview: preview })}
           />
        </div>
      </div>

      <div>
        <div className="flex items-center justify-between">
          <Label htmlFor="edit-prompt">Image Description (Optional)</Label>
          <Button
            type="button"
            variant="outline"
            size="sm"
            onClick={handleAutoGenerateDescription}
            disabled={!editImage || descriptionLoading || loading}
            className="text-xs"
          >
            {descriptionLoading ? (
              <>
                <Loader2 className="mr-1 h-3 w-3 animate-spin" />
                Generating...
              </>
            ) : (
              <>
                <Wand2 className="mr-1 h-3 w-3" />
                Auto Generate
              </>
            )}
          </Button>
        </div>
        <Textarea
          id="edit-prompt"
          placeholder="Describe the current image..."
          value={editPrompt}
          onChange={(e) => updateEditState({ editPrompt: e.target.value })}
          rows={4}
          className="mt-1"
        />
      </div>

      <div>
        <Label htmlFor="edit-instruction">Edit Instructions</Label>
        <Textarea
          id="edit-instruction"
          placeholder="Describe what changes you want to make..."
          value={editInstruction}
          onChange={(e) => updateEditState({ editInstruction: e.target.value })}
          rows={3}
          className="mt-1"
        />
        
        {/* Improve Edit Instructions Button */}
        <div className="mt-3">
          <Button
            variant="outline"
            size="sm"
            onClick={() => handleImprovePrompt('edit')}
            disabled={improvingPrompt || !editInstruction.trim()}
            className="text-xs w-full"
          >
            {improvingPrompt ? (
              <>
                <Loader2 className="mr-2 h-3 w-3 animate-spin" />
                Improving instructions...
              </>
            ) : (
              <>
                <Sparkles className="mr-2 h-3 w-3" />
                Improve Edit Instructions
              </>
            )}
          </Button>
          <p className="text-xs text-muted-foreground mt-1">
            Generate detailed, step-by-step editing instructions
          </p>
        </div>
      </div>

      {/* Resize Option */}
      {originalImageSize && (
        <div className="flex items-center space-x-2 p-3 bg-muted/50 rounded-lg">
          <Checkbox
            id="resize-option"
            checked={resizeToOriginal}
            onCheckedChange={(checked) => setResizeToOriginal(checked as boolean)}
          />
          <Label htmlFor="resize-option" className="text-sm cursor-pointer">
            Resize output to match original image size ({originalImageSize.width}×{originalImageSize.height}px)
          </Label>
        </div>
      )}

      <Button 
        onClick={handleEdit} 
        disabled={loading || !editImage || !editInstruction.trim()}
        className="w-full"
      >
        {loading ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" />
            Editing...
          </>
        ) : (
          <>
            <Edit className="mr-2 h-4 w-4" />
            Edit Image
          </>
        )}
      </Button>
    </div>
  )
}